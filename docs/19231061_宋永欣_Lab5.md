# <center>Lab 5：作用域和全局变量	实验报告</center>

<center>19231061 宋永欣</center>

## Part 8 作用域与块

引入块了之后需要维护符号表（防止重复定义），符号表使用vector实现，链表形式，类图如下。

![](19231061_宋永欣_Lab3.assets/符号表.png)

每次递归下降到`block`子程序时，符号表`SymboleTable`中新增一个`Scope`，然后进入`blockItem`子程序，进行后续工作。

**如何让语句块内声明的变量的生命周期在该语句块内？**

首先讲一下`Scope`增添的机制，`Scope`类中有`parentScopeIndex`，记录该作用域的父作用域，如此我们可以根据父子关系，以树形层层向上搜索。每次递归下降到`block`子程序时，符号表`SymboleTable`中新增一个`Scope`时，都令全局变量当前作用域索引变为新建的这个作用域的索引`curScopeIndex = SymbolTable::addScope(curScopeIndex, kind, isVoidFunc, std::move(funcName));`。当读到`}`时，`curScopeIndex = SymbolTable::exitScope(curScopeIndex);`将全局变量当前作用域索引恢复为该块之前的作用域索引。搜索时，首先在当前scope找，如果未找到，通过Scope类中的`parentScopeIndex`找到当前scope的上一层scope，在该层继续搜索，如此迭代直至**找到**或者到**全局也未找到**。

![](19231061_宋永欣_Lab5.assets/符号表-16409356860711.png)

这样可以有效保证语句块内声明的变量的生命周期在该语句块内。

**同一作用域中不能有同名的变量或常量 & 语句块内可以再次定义与语句块外同名的变量或常量（通过 `Decl` 语句)，其作用域从定义处开始到该语句块尾结束，它隐藏语句块外的同名变量或常量**

由于我采用的这种搜索方式，声明时只在当前`Scope`内检查是否重复，而取值时先在当前`Scope`找，再往上去找，满足了隐藏的要求。

## Part ⑨ 全局变量

- 全局变量之间不允许同名；
- 局部变量可以和全局变量同名，在局部变量作用域内，局部变量隐藏了同名全局变量的定义；

一开始就设计有全局的`Scope`，它的索引值为0，全局变量不允许同名在上面讲`Scope`就已经解决了，全局`Scope`也是`Scope`。

- 全局变/常量声明中指定的初值表达式必须是**常量表达式**；

使用`tryReplaceConst`进行常量替换（之前就用过了），如果不能替换出常量值，则出错

- 未显式初始化的局部变量，其值是不确定的；而未显式初始化的全局变量，其值均被初始化为 0。

特判，如果当前作用域索引`curScopeIndex`为0，且未赋初值，则将变量赋值为0。
